package piperenv

import (
	"bytes"
	"fmt"
	"strings"
	"text/template"
)

// ParseTemplate allows to parse a template which contains references to the CPE
// Utility functions make it simple to access specific parts of the CPE
func (c *CPEMap) ParseTemplate(cpeTemplate string) (*bytes.Buffer, error) {
	funcMap := template.FuncMap{
		"cpe":         c.cpe,
		"cpecustom":   c.custom,
		"git":         c.git,
		"imageDigest": c.imageDigest,
		"imageTag":    c.imageTag,

		// ToDo: add template function for artifacts
		// This requires alignment on artifact handling before, though
	}

	tmpl, err := template.New("cpetemplate").Funcs(funcMap).Parse(cpeTemplate)
	if err != nil {
		return nil, fmt.Errorf("failed to parse cpe template '%v': %w", cpeTemplate, err)
	}

	tmplParams := struct {
		CPE map[string]interface{}
	}{
		CPE: map[string]interface{}(*c),
	}

	var generated bytes.Buffer
	err = tmpl.Execute(&generated, tmplParams)
	if err != nil {
		return nil, fmt.Errorf("failed to execute cpe template '%v': %w", cpeTemplate, err)
	}

	return &generated, nil
}

func (c *CPEMap) cpe(element string) string {
	// ToDo: perform validity checks to allow only selected fields for now?
	// This would allow a stable contract and could perform conversions in case a contract changes.

	el, _ := map[string]interface{}(*c)[element].(string)
	return el
}

func (c *CPEMap) custom(element string) string {
	el, ok := map[string]interface{}(*c)[fmt.Sprintf("custom/%v", element)].(string)
	if ok {
		return el
	}
	return fmt.Sprint(map[string]interface{}(*c)[fmt.Sprintf("custom/%v", element)])
}

func (c *CPEMap) git(element string) string {
	var el string
	if element == "organization" || element == "repository" {
		el, _ = map[string]interface{}(*c)[fmt.Sprintf("github/%v", element)].(string)
	} else {
		el, _ = map[string]interface{}(*c)[fmt.Sprintf("git/%v", element)].(string)
	}
	return el
}

func (c *CPEMap) imageDigest(imageName string) string {
	digests, _ := map[string]interface{}(*c)["container/imageDigests"].([]string)
	imageNames, _ := map[string]interface{}(*c)["container/imageNames"].([]string)
	if len(digests) > 0 && len(digests) == len(imageNames) {
		for i, image := range imageNames {
			if image == imageName {
				return digests[i]
			}
		}
	}
	return ""
}

func (c *CPEMap) imageTag(imageName string) string {
	nameTags, _ := map[string]interface{}(*c)["container/imageNameTags"].([]string)
	for _, nameTag := range nameTags {
		nt := strings.Split(nameTag, ":")
		if nt[0] == imageName {
			return nt[1]
		}
	}
	return ""
}
